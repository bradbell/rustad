// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-or-later
// SPDX-FileCopyrightText: Bradley M. Bell <bradbell@seanet.com>
// SPDX-FileContributor: 2025 Bradley M. Bell
// ---------------------------------------------------------------------------
//
//! Implement the ADfn [ADfn::rust_src] method
//! (rust source code for function value).
//!
//! Link to [parent module](super)
// ---------------------------------------------------------------------------
// use
//
use crate::ad::ADType;
use crate::{
    ADfn,
};
//
use std::any::type_name;
use crate::op::info::sealed::GlobalOpInfoVec;
//
#[cfg(doc)]
use crate::{
    doc_generic_v,
    doc_generic_e,
    RustSrcLink,
};
// -----------------------------------------------------------------------
/// Prototype for the source code generated by [ADfn::rust_src].
///
/// * Syntax :
/// rust_src_ *fn_name* ( *dyp_dom*  , *var_dom* )
/// -> Result< *range* , *msg*  >
///
/// * dyp_dom :
/// a vector containing the references to the
/// domain dynamic parameter values;
///
/// * var_dom :
/// a vector containing the references to the
/// domain variable values;
///
/// * range :
/// If the return matches Ok, range contains the range vector
/// corresponding to the domain sub-vectors.
///
/// * msg :
/// If the return matches Err, msg is the corresponding error message.
//
// RustSrcFn
pub type RustSrcFn<V> = fn(
    dyp_dom      : &Vec<&V>,
    var_dom      : &Vec<&V>,
) -> Result< Vec<V>, String >;
//
// prototype_src
fn prototype_src(fn_name : &str, v_str : &str) -> String {
    let result = String::new();
    let result = result +
        "#[no_mangle]\n" +
        "pub fn rust_src_"  + fn_name + "(\n" +
        "   dyp_dom     : &Vec<&"    + v_str  + ">,\n" +
        "   var_dom     : &Vec<&"    + v_str  + ">,\n" +
        ") -> Result< Vec<" + v_str  + ">, String >\n" ;
    result
}
// -----------------------------------------------------------------------
// rust_src
impl<V> ADfn<V>
where
    V : ToString + From<f32> +  GlobalOpInfoVec ,
{
    /// Rust source code for zero order forward mode evaluation; i.e.,
    /// function value.
    ///
    /// * V : see [doc_generic_v]
    /// * E : see [doc_generic_e]
    /// * f : is an [ADfn] object.
    ///
    /// * fn_name :
    /// is the name of the rust function created by this operation.
    /// The actual function name will be `rust_src_` followed by *fn_name* .
    ///
    /// * return :
    /// The returned string is rust source code for an evaluation
    /// of function values for this ADfn object; see [RustSrcFn] .
    ///
    /// * Example: see examples/rust_src.rs
    pub fn rust_src(&self, fn_name : &str) -> String {
        //
        // op_info_vec
        let op_info_vec = &*<V as GlobalOpInfoVec>::get();
        //
        // v_str
        let v_str   = String::from( type_name::<V>() );
        let v_str   = v_str.replace( "rustad::az_float::AzFloat", "AzFloat" );
        //
        // prototype
        let mut src = prototype_src(fn_name, &v_str);
        //
        // begin function body
        src = src + "{\n";
        //
        // check dyp_dom
        let expect = self.dyp.n_dom.to_string();
        src = src +
            "   // check dyp_dom\n" +
            "   if dyp_dom.len() != " + &expect  + " {\n" +
            "       let msg  = \"dyp_dom length != " + &expect + "\";\n" +
            "       let msg  = String::from(msg);\n" +
            "       return Err(msg);\n" +
            "   }\n";
        //
        // check var_dom
        let expect = self.var.n_dom.to_string();
        src = src +
            "   // check var_dom\n" +
            "   if var_dom.len() != " + &expect  + " {\n" +
            "       let msg  = \"var_dom length != " + &expect + "\";\n" +
            "       let msg  = String::from(msg);\n" +
            "       return Err(msg);\n" +
            "   }\n";
        //
        // V
        src = src +
            "   //\n" +
            "   // V\n" +
            "   type V = " + &v_str + ";\n";
        //
        // nan
        src = src +
            "   //\n" +
            "   // nan\n" +
            "   let nan = V::from( f32::NAN );\n";
        //
        // cop
        if 0 < self.cop.len() {
            let n_cop = self.cop.len().to_string();
            src = src +
                "   // cop\n" +
                "   let mut cop : Vec<V> = " + "vec![nan; " + &n_cop + "];\n";
            for i in 0 .. self.cop.len() {
                let i_str = i.to_string();
                let c_str = self.cop[i].to_string();
                src = src +
                    "   cop[" + &i_str + "] = V::from(" + &c_str + ");\n";
            }
        }
        //
        // dyp_dep
        if self.dyp.n_dep > 0 {
            let n_dep = self.dyp.n_dep.to_string();
            src = src +
                "   //\n" +
                "   // dyp_dep\n" +
                "   // vector of dependent variables\n" +
                "   let mut dyp_dep : Vec<V> = vec![nan; " + &n_dep + "];\n";
            //
            // dyp_dep
            for op_index in 0 .. self.dyp.id_seq.len() {
                let op_id    = self.dyp.id_seq[op_index] as usize;
                let start    = self.dyp.arg_seq[op_index] as usize;
                let end      = self.dyp.arg_seq[op_index + 1] as usize;
                let arg      = &self.dyp.arg_all[start .. end];
                let arg_type = &self.dyp.arg_type_all[start .. end];
                let res      = self.dyp.n_dom + op_index;
                let rust_src = op_info_vec[op_id].rust_src;
                let not_used = V::from( f32::NAN );
                src = src + &rust_src(
                        not_used,
                        ADType::DynamicP,
                        self.dyp.n_dom,
                        self.var.n_dom,
                        &self.dyp.flag_all,
                        arg,
                        arg_type,
                        res
                    );
            }
        }
        //
        // var_dep
        if self.var.n_dep > 0 {
            let n_dep = self.var.n_dep.to_string();
            src = src +
                "   //\n" +
                "   // var_dep\n" +
                "   // vector of dependent variables\n" +
                "   let mut var_dep : Vec<V> = vec![nan; " + &n_dep + "];\n";
            for op_index in 0 .. self.var.id_seq.len() {
                let op_id    = self.var.id_seq[op_index] as usize;
                let start    = self.var.arg_seq[op_index] as usize;
                let end      = self.var.arg_seq[op_index + 1] as usize;
                let arg      = &self.var.arg_all[start .. end];
                let arg_type = &self.var.arg_type_all[start .. end];
                let res      = self.var.n_dom + op_index;
                let rust_src = op_info_vec[op_id].rust_src;
                let not_used = V::from( f32::NAN );
                src = src + &rust_src(
                        not_used,
                        ADType::Variable,
                        self.dyp.n_dom,
                        self.var.n_dom,
                        &self.var.flag_all,
                        arg,
                        arg_type,
                        res
                    );
            }
        }
        //
        // range
        let n_range = self.rng_ad_type.len();
        src = src +
            "   //\n" +
            "   // range\n" +
            "   let mut range : Vec<V> = " +
                     "Vec::with_capacity(" + &n_range.to_string() + ");\n";
        for i in 0 .. n_range {
            let index = self.rng_index[i] as usize;
            if self.rng_ad_type[i].is_variable() {
                if index < self.var.n_dom {
                    let i_str = index.to_string();
                    src = src +
                        "   range.push( var_dom[" + &i_str + "].clone() );\n";
                } else {
                    let i_str = (index - self.var.n_dom).to_string();
                    src = src +
                        "   range.push( var_dep[" + &i_str + "].clone() );\n";
                    }
            } else if self.rng_ad_type[i].is_dynamic() {
                if index < self.dyp.n_dom {
                    let i_str = index.to_string();
                    src = src +
                        "   range.push( dyp_dom[" + &i_str + "].clone() );\n";
                } else {
                    let i_str = (index - self.dyp.n_dom).to_string();
                    src = src +
                        "   range.push( dyp_dep[" + &i_str + "].clone() );\n";
               }
            } else {
                assert!( self.rng_ad_type[i].is_constant() );
                //
                let i_str = index.to_string();
                 src = src +
                    "   range.push( cop[" + &i_str + "].clone() );\n";
            }
        }
        //
        // end function body
        src = src +
            "   //\n" +
            "   Ok(range)\n" +
           "}\n";
        //
        src
    }
}
